/*
 * Copyright 2017-2022 Avery Carroll and Logan Devecka
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.sandrabot.sandra.api.handlers

import com.sandrabot.sandra.Sandra
import com.sandrabot.sandra.api.jsonResult
import com.sandrabot.sandra.entities.EndpointHandler
import com.sandrabot.sandra.utils.*
import io.javalin.http.*
import io.ktor.client.call.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.util.cio.*
import io.ktor.utils.io.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import org.slf4j.LoggerFactory
import java.io.File
import java.util.zip.ZipFile
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import kotlin.time.ExperimentalTime
import kotlin.time.measureTimedValue

@Suppress("unused")
class DeployHandler(private val sandra: Sandra) : EndpointHandler("deploy", type = HandlerType.POST) {

    private val secretKey = SecretKeySpec(sandra.credentials.githubSecret.toByteArray(), "HmacSHA256")
    private var deployEnabled = false

    @OptIn(ExperimentalTime::class)
    override fun handle(context: Context) {
        // first things first, make sure deployments are enabled on our end
        if (!deployEnabled) {
            logger.warn("Deploy endpoint was reached, however deployments are disabled")
            throw ServiceUnavailableResponse()
        }

        // validate that this request originated from and authenticated by GitHub
        val hmac = Mac.getInstance("HmacSHA256").apply { init(secretKey) }
        val signature = "sha256=" + hmac.doFinal(context.bodyAsBytes()).joinToString("") { "%02x".format(it) }
        if ("X-Hub-Signature-256" !in context.headerMap()) throw UnauthorizedResponse("Missing signature")
        if (context.header("X-Hub-Signature-256") != signature) throw ForbiddenResponse("Invalid signature")
        val runId = context.formParam("runId")?.toLongOrNull() ?: throw BadRequestResponse("Missing runId parameter")
        logger.info("Verified deployment request from GitHub action $runId, preparing update...")

        // download the latest build from the action that triggered the deployment
        val latestBuildZip = File("latest-build.zip")
        runBlocking(Dispatchers.IO) {
            // retrieve the list of artifacts generated by this action
            val actionArtifacts = try {
                // this endpoint does not require any authentication
                httpClient.get("https://api.github.com/repos/sandrabot/sandra/actions/runs/$runId/artifacts")
            } catch (t: Throwable) {
                logger.error("Failed to retrieve artifacts for GitHub action $runId", t)
                throw BadGatewayResponse("Failed to retrieve artifacts")
            }

            // find the first artifact with the name "build-libs", which contains our binaries
            val artifactResponse = actionArtifacts.body<JsonObject>()
            // throw if the "total_count" is null or already zero
            if ((artifactResponse.int("total_count") ?: 0) == 0) throw BadGatewayResponse("Job has no artifacts")
            val libArtifact = artifactResponse["artifacts"]!!.jsonArray.map { it.jsonObject }.find {
                it.string("name") == "build-libs"
            } ?: throw BadGatewayResponse("Job is missing artifact")
            // make sure the job artifacts are not expired, just to be safe
            if (libArtifact.boolean("expired") == true) throw BadRequestResponse("Artifact is expired")
            val libSizeBytes = libArtifact.long("size_in_bytes") ?: throw BadGatewayResponse("Missing size_in_bytes")
            val downloadUrl = libArtifact.string("archive_download_url") ?: throw BadGatewayResponse("Missing archive_download_url")
            logger.info("Downloading build-libs with size $libSizeBytes from $downloadUrl")

            // time how long it takes to download the file from GitHub
            val timedDownload = measureTimedValue {
                val download = try {
                    // this endpoint requires authentication with an actions scope
                    httpClient.get(downloadUrl) { header("Authorization", "Bearer ${sandra.credentials.githubToken}") }
                } catch (t: Throwable) {
                    logger.error("Failed to download artifacts for GitHub action $runId", t)
                    throw BadGatewayResponse("Failed to download artifacts")
                }
                download.bodyAsChannel().copyAndClose(latestBuildZip.writeChannel())
            }

            // finish processing the downloaded file from GitHub
            logger.info("Finished downloading artifact in ${timedDownload.duration} with size ${timedDownload.value} to ${latestBuildZip.absolutePath}")
            ZipFile(latestBuildZip).use { zip ->
                // extract only the shadow jar and rename it to something better
                val entry = zip.entries().toList().first { it.name.endsWith("-all.jar") }
                zip.getInputStream(entry).use { File("sandra-latest.jar").outputStream().use(it::copyTo) }
                logger.info("Selected and extracted binary ${entry.name} for installation")
            }
            latestBuildZip.delete()
        }
        jsonResult(context)
    }

    private companion object {
        private val logger = LoggerFactory.getLogger(DeployHandler::class.java)
    }

}
